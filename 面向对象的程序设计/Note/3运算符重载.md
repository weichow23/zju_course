## 运算符重载
定义对象的运算。多次重载时，根据实参的类型决定调用哪个运算符函数
```c++
返回值类型  operator 运算符(形参表){
    ...
}
```
- 可以重载为普通函数（参数个数为运算目数）
- 也可以重载为成员函数（运算目数减一）
示例：
```c++
class Complex{
    public:
        double real, imag;
        Complex( double r=0.0, double i=0.0): real(r),imag(i){ }
        Complex operator - (const Complex &c){
            return Complex(real - c.real, imag - c.imag);//返回一个临时对象 
        }
};
Complex operator+(const Complex &a, const Complex &b){
    return Complex( a.real + b.real, a.imag +b.imag); //返回一个临时对象
}

int main(){
    ...
    c = a + b; //等价于 c = operator+(a,b);
    c = a - b; //等价于 c = a.operator-(b);
}
```

#### 等号重载
只能重载为成员函数。防止浅拷贝（不是拷贝一份相同的内容，而是使指针指向同一片存储空间，这样的话对同一个new的空间析构两次就会出现问题）
**注意区分初始化和赋值**
 一般返回类型为``type &``
例：
```c++
//String &可以有原值返回， void，String也行，但是考虑运算符原本特性还是String &更好
String & operator = (const String & s){  
    if( this == &s)
        return *this; //防止 s=s;
    delete [ ] str;
    str = new char[strlen(s.str)+1];
    strcpy( str, s.str);
    return *this;
}
//并且需要注意修改复制构造函数,防止复制构造函数出现浅拷贝
String(String &s){
    str = new char[strlen(s.str)+1];
    strcpy(str, s.str);
}
```
#### 重载为友元函数
重载为普通函数，但又需要访问类的私有成员时，需要将运算符重载为友元
#### 流运算符重载
只能重载为全局函数，因为i/ostream已经写好了
```c++
ostream & operator<<( ostream &a ,... ){
    ...
    return a;
}

istream & operator<<( istream &a ,... ){
    ...
    return a;
}
```
#### 类型转换重载
```c++
#include<iostream>
using namespace std;
class Complex{
    double real,imag;
    public:
        Complex(double r=0, double i=0):real(r),imag(i){ };
        operator double(){ return real;}  //强制类型转换为double
        //前面无需说明类型，因为强制类型转换结果类型就是转换的类型
};
int main(){
    Complex c(1.2,3.4);
    cout<< (double)c <<endl ; //输出1.2
    double n = 2+c; //c会被强制类型转换，相当于double n=2+c.operator double()
    //强制转换的前提为该类型的类型转换已经重载过
}
```
#### 自增自减重载
前置作为一元运算符重载（在c中前置返回的是运算后的结果，因此用``&``来保持尽量一致）
**形参传入引用，因为需要修改**
```c++
//重载为成员函数
type & operator ++();
//重载为全局函数
type1 & operator++(type2);
```
后置重载为二元运算符，多写一个没用的参数（以区别前置）
```c++
//重载为成员函数
type operator ++(int);
//重载为全局函数
type1 operator --(type2 , int);
```
> 在没有后置运算符重载而有前置时，在vs中，后置也调用前置，Dev则报错