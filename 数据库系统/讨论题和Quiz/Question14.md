> 基于封锁的协议是一类悲观并发控制方法，它假定事务访问数据冲突概率较大，因此在事务访问数据前都要先获得该数据上的锁，当检测到冲突时，事务强制进入等待。但是，在事务访问数据冲突概率较小的场合，基于封锁的协议管理代价太大。那么，有没有乐观的并发控制方法，免去封锁管理的代价，适用于事务访问数据冲突概率较小的场合？

有，比如 **基于时间戳的并发控制（Timestamp-based concurrency control）**。

在基于时间戳的并发控制中，每个事务被分配一个唯一的时间戳，用于标识事务的开始时间。当事务要访问某个数据项时，系统会为该数据项分配一个时间戳，表示数据项最后一次被修改的时间,  事务可以通过比较时间戳来确定是否存在冲突。

当一个事务要修改数据项时，它会首先检查该数据项的时间戳是否晚于事务的开始时间戳，如果是，则表示该数据项已经被其他事务修改，当前事务需要中止并重新开始。如果时间戳较早，表示数据项未被修改，事务可以进行修改操作，并将自己的时间戳作为数据项的新时间戳。

然而，基于时间戳的并发控制方法可能会导致事务的中止和重启，可能会降低并发性能
