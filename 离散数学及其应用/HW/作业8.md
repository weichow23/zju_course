# Section 5.4

### 14

假设$k$为被删除的词的数量

输入是一个$a_1, a_2,..., a_n $的整数列表。称这个列表为$ L$。如果$ n = 1$（基本情况），那么输出是$a_1$，它出现$1$次

对于递归情况$(n>1)$，形成一个新的列表$L'$, 从$L$中删除术语an和L中等于$a_n$的所有术语。如果$k=n$（换句话说，如果$L'$是空列表），那么输出是$a_n$，并且它出现了$n$次。否则，对$L'$递归应用该算法，得到一个模式$m$，它出现了$t$次。现在，如果$t \ge k$
那么输出结果是$m$，它出现了$t$次；否则输出结果是模式是$a_n$，它出现了$k$次

### 17

```pseudocode
procedure multiply(x, y: nonnegative integers)
if y = 0 then return 0
else if y is even then
	return 2*multiply (x, y∕2)
else 
	return 2*multiply (x, (y−1)∕2) + x
```

### 23

伪代码为

```pseudocode
procedure square(n: nonnegative integer)
	if n = 0 then 
		return 0
	else 
		return square (n − 1) + 2(n − 1) + 1
```

该算法在输入为$0$的情况下也能正确工作

`if子句`，如果输入为0，则该算法工作正常。那么对于输入的$k+1$，它的输出是 它的输出

`else子句`, 是当输入为$k$，加上$2（k+1-1）+1$。根据归纳的假设，它在$k$处的输出是$k^2$，所以它在$k+1$处的输出是$ k^2 + 2(k + 1 - 1) + 1 = k^2 + 2k + 1 = (k + 1)^2$

### 35

```pseudocode
procedure r(n: 非负整数)
	if n < 3 then 
		return 2n + 1
	else 
		return r(n − 1) ⋅ (r(n − 2))2 ⋅ (r(n − 3))3

procedure i(n: 非负整数)
	if n = 0 then 
		z := 1
	else if n = 1 then 
		z := 3
	else
		x := 1
		y := 3
		z := 5
		for i := 1 to n − 2
			w := z ⋅ y2 ⋅ x3
			x := y
			y := z
			z := w
return z {z is the nth term of the sequence}
```

### 53

6

### 54

应该是  $3+0+1=4$

在最好的情况下，最初的分割将需要$3$次比较，并导致长度为$1$和$2$的子列表仍然需要被排序的子列表。这两个子列表分别需要$0$和$1$次比较，而且列表已经被排序了

### 55

$O(n^2)$

每次找的pivot将数组分成两部分，其中有一部分是空，这样递归树就变成了一棵倾斜的树。树的深度为$n-1$,这样时间复杂度就变成了$O(n^2)$
